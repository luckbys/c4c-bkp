// Script para testar resposta do agente IA em ticket espec√≠fico
const { initializeApp } = require('firebase/app');
const { getFirestore, collection, getDocs, query, orderBy, limit, onSnapshot, doc, getDoc } = require('firebase/firestore');
require('dotenv').config({ path: '.env.local' });

// Configura√ß√£o do Firebase
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const BASE_URL = 'http://localhost:9003';
const TARGET_PHONE = '5512981022013'; // N√∫mero do cliente que reportou o problema

async function testSpecificTicketResponse() {
  console.log('üéØ TESTE DE RESPOSTA PARA TICKET ESPEC√çFICO');
  console.log('=' .repeat(60));
  console.log(`üì± N√∫mero alvo: +${TARGET_PHONE}`);
  console.log(`‚è∞ Iniciado em: ${new Date().toLocaleString('pt-BR')}`);
  
  try {
    // 1. Buscar ticket espec√≠fico
    console.log('\n1. üîç BUSCANDO TICKET DO CLIENTE...');
    const ticket = await findTargetTicket();
    
    if (!ticket) {
      console.log('‚ùå Ticket n√£o encontrado');
      return;
    }
    
    console.log(`‚úÖ Ticket encontrado: ${ticket.id}`);
    console.log(`   üìä Status: ${ticket.status}`);
    console.log(`   ü§ñ Agente: ${ticket.assignedAgent?.name} (${ticket.assignedAgent?.type})`);
    console.log(`   üîß Auto Response: ${ticket.aiConfig?.autoResponse}`);
    console.log(`   üì± Cliente: ${ticket.client?.name}`);
    console.log(`   üè¢ Instance: ${ticket.instanceName}`);
    
    // 2. Verificar configura√ß√£o
    if (!ticket.assignedAgent || ticket.assignedAgent.type !== 'ai') {
      console.log('‚ùå Ticket n√£o tem agente IA atribu√≠do');
      return;
    }
    
    if (!ticket.aiConfig?.autoResponse) {
      console.log('‚ùå Auto response n√£o est√° habilitado');
      return;
    }
    
    // 3. Configurar monitoramento
    console.log('\n2. üéß CONFIGURANDO MONITORAMENTO...');
    setupTicketMonitoring(ticket.id);
    
    // 4. Aguardar configura√ß√£o
    console.log('‚è≥ Aguardando 2 segundos...');
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // 5. Enviar mensagem de teste
    console.log('\n3. üì§ ENVIANDO MENSAGEM DE TESTE...');
    const success = await sendTestMessage(ticket);
    
    if (success) {
      console.log('‚úÖ Mensagem enviada com sucesso');
      console.log('\n‚è≥ Monitorando resposta por 30 segundos...');
      console.log('   (O agente IA deve responder automaticamente)');
      
      // Aguardar resposta
      await new Promise(resolve => setTimeout(resolve, 30000));
      
      console.log('\n‚è∞ Monitoramento finalizado');
      
      // 6. Verificar se houve resposta
      console.log('\n4. üîç VERIFICANDO RESULTADO...');
      await checkFinalResult(ticket.id);
      
    } else {
      console.log('‚ùå Falha ao enviar mensagem de teste');
    }
    
  } catch (error) {
    console.error('‚ùå Erro durante teste:', error);
  }
}

async function findTargetTicket() {
  try {
    console.log('   üìã Listando todos os tickets recentes...');
    
    const ticketsRef = collection(db, 'tickets');
    const q = query(ticketsRef, orderBy('updatedAt', 'desc'), limit(50));
    
    const querySnapshot = await getDocs(q);
    const allTickets = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    
    console.log(`   üìä ${allTickets.length} tickets encontrados`);
    
    // Buscar pelo n√∫mero do cliente
    const targetTicket = allTickets.find(ticket => {
      const clientId = ticket.client?.id || ticket.remoteJid || '';
      return clientId.includes(TARGET_PHONE);
    });
    
    if (targetTicket) {
      console.log(`   ‚úÖ Ticket encontrado para ${TARGET_PHONE}`);
      return targetTicket;
    }
    
    console.log(`   ‚ùå Nenhum ticket encontrado para ${TARGET_PHONE}`);
    console.log('   üìã Tickets dispon√≠veis:');
    
    allTickets.slice(0, 10).forEach((ticket, index) => {
      const clientId = ticket.client?.id || ticket.remoteJid || 'N/A';
      const clientName = ticket.client?.name || 'N/A';
      console.log(`      ${index + 1}. ${clientName} (${clientId})`);
    });
    
    return null;
    
  } catch (error) {
    console.error('   ‚ùå Erro ao buscar tickets:', error);
    return null;
  }
}

function setupTicketMonitoring(ticketId) {
  console.log('   üéß Configurando listener para o ticket...');
  
  // Monitor do ticket espec√≠fico
  const ticketDocRef = doc(db, 'tickets', ticketId);
  
  onSnapshot(ticketDocRef, (docSnapshot) => {
    if (docSnapshot.exists()) {
      const data = docSnapshot.data();
      
      if (data.messages && data.messages.length > 0) {
        const lastMessage = data.messages[data.messages.length - 1];
        const timestamp = new Date().toLocaleTimeString('pt-BR');
        
        console.log(`\nüìù [${timestamp}] NOVA MENSAGEM NO TICKET:`);
        console.log(`   üí¨ Conte√∫do: "${lastMessage.content?.substring(0, 150)}..."`);
        console.log(`   üë§ De: ${lastMessage.fromMe ? 'üè¢ Empresa' : 'üë§ Cliente'}`);
        console.log(`   üÜî ID: ${lastMessage.id}`);
        console.log(`   ‚è∞ Timestamp: ${new Date(lastMessage.timestamp).toLocaleString('pt-BR')}`);
        
        if (lastMessage.fromMe) {
          console.log('   üéâ RESPOSTA DO AGENTE IA DETECTADA!');
        }
      }
    }
  });
  
  // Monitor de intera√ß√µes do agente
  console.log('   üéß Configurando listener para intera√ß√µes...');
  
  const interactionsRef = collection(db, 'agent_interactions');
  
  onSnapshot(interactionsRef, (snapshot) => {
    snapshot.docChanges().forEach((change) => {
      if (change.type === 'added') {
        const data = change.doc.data();
        
        if (data.ticketId === ticketId) {
          const timestamp = new Date().toLocaleTimeString('pt-BR');
          
          console.log(`\nü§ñ [${timestamp}] INTERA√á√ÉO DO AGENTE:`);
          console.log(`   üìä Tipo: ${data.type}`);
          console.log(`   üéØ Confian√ßa: ${data.confidence || 'N/A'}`);
          console.log(`   üí¨ Resposta: "${data.response?.substring(0, 100) || 'N/A'}..."`);
          
          if (data.error) {
            console.log(`   ‚ùå Erro: ${data.error}`);
          }
          
          if (data.type === 'auto_response') {
            console.log('   ‚úÖ RESPOSTA AUTOM√ÅTICA PROCESSADA!');
          } else if (data.type === 'low_confidence') {
            console.log('   ‚ö†Ô∏è RESPOSTA REJEITADA POR BAIXA CONFIAN√áA!');
          }
        }
      }
    });
  });
  
  console.log('   ‚úÖ Monitoramento configurado');
}

async function sendTestMessage(ticket) {
  try {
    const webhookPayload = {
      instance: ticket.instanceName || 'loja',
      data: {
        key: {
          remoteJid: ticket.client?.id || ticket.remoteJid,
          fromMe: false,
          id: `test_specific_${Date.now()}`
        },
        message: {
          conversation: 'Ol√°! Preciso de ajuda com meu pedido. Voc√™s podem me ajudar? Este √© um teste para verificar se o agente IA est√° funcionando.'
        },
        messageTimestamp: Math.floor(Date.now() / 1000),
        pushName: ticket.client?.name || 'Cliente Teste'
      }
    };
    
    console.log('   üìã Enviando webhook:');
    console.log(`      Instance: ${webhookPayload.instance}`);
    console.log(`      Cliente: ${webhookPayload.data.key.remoteJid}`);
    console.log(`      Mensagem: "${webhookPayload.data.message.conversation}"`);
    
    const response = await fetch(`${BASE_URL}/api/webhooks/evolution/messages-upsert`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': 'webhook_secret_key_2024'
      },
      body: JSON.stringify(webhookPayload)
    });
    
    if (response.ok) {
      const responseText = await response.text();
      console.log(`   ‚úÖ Webhook aceito: ${response.status}`);
      console.log(`   üìÑ Resposta: ${responseText}`);
      return true;
    } else {
      const errorText = await response.text();
      console.log(`   ‚ùå Erro no webhook: ${response.status} - ${errorText}`);
      return false;
    }
    
  } catch (error) {
    console.log(`   ‚ùå Erro ao enviar: ${error.message}`);
    return false;
  }
}

async function checkFinalResult(ticketId) {
  try {
    console.log('   üîç Verificando estado final do ticket...');
    
    const ticketDocRef = doc(db, 'tickets', ticketId);
    const ticketDoc = await getDoc(ticketDocRef);
    
    if (ticketDoc.exists()) {
      const data = ticketDoc.data();
      
      if (data.messages && data.messages.length > 0) {
        const messages = data.messages;
        const lastMessages = messages.slice(-3); // √öltimas 3 mensagens
        
        console.log('   üìù √öltimas mensagens:');
        lastMessages.forEach((msg, index) => {
          const from = msg.fromMe ? 'üè¢ Empresa' : 'üë§ Cliente';
          const time = new Date(msg.timestamp).toLocaleTimeString('pt-BR');
          console.log(`      ${index + 1}. [${time}] ${from}: "${msg.content?.substring(0, 80)}..."`);
        });
        
        // Verificar se h√° resposta da empresa ap√≥s a mensagem de teste
        const hasResponse = messages.some(msg => 
          msg.fromMe && 
          msg.timestamp > Date.now() - 60000 // √öltimos 60 segundos
        );
        
        if (hasResponse) {
          console.log('\n   ‚úÖ SUCESSO: Agente IA respondeu!');
        } else {
          console.log('\n   ‚ùå PROBLEMA: Agente IA n√£o respondeu');
        }
      }
    }
    
    // Verificar intera√ß√µes do agente
    console.log('\n   ü§ñ Verificando intera√ß√µes do agente...');
    
    const interactionsRef = collection(db, 'agent_interactions');
    const q = query(interactionsRef, orderBy('timestamp', 'desc'), limit(5));
    
    const querySnapshot = await getDocs(q);
    const recentInteractions = querySnapshot.docs
      .map(doc => doc.data())
      .filter(interaction => 
        interaction.ticketId === ticketId &&
        interaction.timestamp > Date.now() - 60000
      );
    
    if (recentInteractions.length > 0) {
      console.log(`   üìä ${recentInteractions.length} intera√ß√µes recentes encontradas:`);
      recentInteractions.forEach((interaction, index) => {
        console.log(`      ${index + 1}. Tipo: ${interaction.type}, Confian√ßa: ${interaction.confidence || 'N/A'}`);
      });
    } else {
      console.log('   ‚ö†Ô∏è Nenhuma intera√ß√£o do agente encontrada');
      console.log('   üí° Isso indica que o webhook pode n√£o estar acionando o agente');
    }
    
  } catch (error) {
    console.error('   ‚ùå Erro ao verificar resultado:', error);
  }
}

// Executar teste
console.log('üöÄ Iniciando teste espec√≠fico...');
testSpecificTicketResponse().catch(console.error);